<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category/>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>false</autorun>
 <autorun-early>false</autorun-early>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>ruby</interpreter>
 <dsl-interpreter-name/>
 <text># Back Annotate v0.43 Dec 17th 2022 Copy right Seijiro Moriyama
module Backannotate
  include RBA
  # require 'YAML'
  class Backannotate
    attr_accessor :ba, :ba_type
    def initialize cv
      @ba_type = '*unknown*'
      ba_file = cv.filename.sub(/\..*/,'_ba.yaml')
      if File.exist? ba_file
        @ba = YAML.load File.read(ba_file)
        @converted = []
        @ba_type = '*final*'
      else
        ba_file = cv.filename.sub(/\..*/,'_table.yaml')
        if File.exist? ba_file
          initialize_ba_data ba_file
          @ba_type = '*initial*'
        end
      end
    end
    def initialize_ba_data ba_file
      ba_table = YAML.load(File.read(ba_file))['M']
      ba_data = {}
      ba_table.each_pair{|type, device|
        ba_data[type] ||= {}
        device.each_pair{|l, w_group|
          w_group.each_pair{|w_m, w_params|
            w_m =~ /(\S+)\*(\S+)/
            w = $1.to_f
            m = $2.to_i
            as_tot = ad_tot = ps_tot = pd_tot = 0
            w_params.each{|params|
              puts "params=#{params.inspect}"  
              as, ad, ps, pd = params[1]
              as_tot = as_tot + as
              ad_tot = ad_tot + ad
              ps_tot = ps_tot + ps
              pd_tot = pd_tot + pd
            }
            puts "m(#{m}) for #{w}/#{l} weird! should be #{w_params.size}" if m != w_params.size
            key = "#{w}/#{l}/#{m}"
            ba_data[type][key] ||= {}
            ba_data[type][key] = {'M' =&gt; m, 'AS' =&gt; as_tot.round(6), 'AD' =&gt; ad_tot.round(6), 
                                         'PS' =&gt; ps_tot.round(6), 'PD' =&gt; pd_tot.round(6)}
            puts "#{type}: l=#{l} w=#{w} m=#{w_params.size} =&gt; total: (#{as_tot}, #{ad_tot}, #{ps_tot}, #{pd_tot})"
          } 
        }
      }      
      @ba = ba_data
      puts ba_data.to_yaml
    end
    def inside? box, x, y
      (x &gt; box.p1.x) &amp;&amp; (x &lt; box.p2.x) &amp;&amp;
      (y &gt; box.p1.y) &amp;&amp; (y &lt; box.p2.y)
    end
    def backannotate file, ba=@ba, &amp;block
      Dir.chdir(File.dirname file){
        ckt_name = File.basename(file).sub(File.extname(file), '').upcase
        # puts "ckt_name=#{ckt_name}"
        # puts "ba: #{ba.inspect}"
        (ba[ckt_name] &amp;&amp; ba = ba[ckt_name])||(ba['.TOP'] &amp;&amp; ba = ba['.TOP'])
        #netlist = File.read(file).encode('UTF-8')
        netlist = File.open(file, 'r:Windows-1252').read.encode('UTF-8', invalid: :replace)
        header = netlist.slice(0..100)
        if ['.net', '.cir', '.spice', '.spc', '.sp'].include? File.extname(file).downcase
          ba_netlist netlist, file, ba, &amp;block if @ba_type == '*initial*'
          ba_netlist_final netlist, file, ba, &amp;block if @ba_type == '*final*'
        elsif header =~ /xschem/
          ba_xschem netlist, file, ba, &amp;block  if @ba_type == '*initial*'
          ba_xschem_final netlist, file, ba, &amp;block  if @ba_type == '*final*'
        elsif header =~ /^Version 4/
          ba_ltspice netlist, file, ba, &amp;block    if @ba_type == '*initial*'
          ba_ltspice_final netlist, file, ba, &amp;block    if @ba_type == '*final*'
        end
      }
    end
    def formalize_parameters w, m, as, ad, ps, pd, formalize=false
      if formalize
        if m == 1
        " as=#{as}=&gt;{#{w}u*#{(as/w).round(4)}u} ps=#{ps}u=&gt;{(#{w}u+#{(ps/2 - w).round(4)}u)*2}"
        else
        " as=#{as}=&gt;{#{w}u*#{(as/w).round(4)}u} ps=#{ps}u=&gt;{(#{w}u+#{((ps*m/2 - w)/m).round(4)}u*#{m})*2/#{m}}"
        end
      else # {(2u+4u)*2} = ps
        " as=#{as}p ad=#{ad}p ps=#{ps}u pd=#{pd}u"
      end
    end
    def update_parameters l, params, current, new_netlist
      as = params['AS'].to_f
      ad = params['AD'].to_f
      ps = params['PS'].to_f
      pd = params['PD'].to_f
      w = params['W'].to_f
      erased = current.gsub(/ [apAP][sdSD]=\S+/, '') 
      if m = params['M']
        m = params['M'].to_i
        erased = erased.gsub(/ [mMwW]=\S+/, '') + " w=#{w}u m=#{m}"
      else
        erased = erased.gsub(/ [mMwW]=\S+/, '') + " w=#{w}u"
      end
      new_netlist &lt;&lt;  l.sub(current, erased  + 
        formalize_parameters(w, m, (as/m).round(4), (ad/m).round(4), (ps/m).round(4), (pd/m).round(4), true)) 
    end
    def v_in_micron desc
      if desc =~ /(\S+)[uU]/
        $1.to_f.round(4)
      elsif desc =~/(\S+)[nN]/
        ($1.to_f * 1.0e-3).round(4)
      else
        (desc.to_f * 1.0e6).round(4)
      end
    end
    def ba_netlist netlist, file, ba_data=@ba, &amp;block
      new_netlist = ''
      netlist.each_line{|l|
        if l =~ /^[Mm]\S+ +\S+ +\S+ +\S+ +\S+ +(\S+) +(.*)$/
          dc = $1
          current = $2
          if ba_data[dc]
            puts ba_data[dc].inspect
            param = current.upcase.scan(/(\S+) *= *(\S+)/).to_h
            m = param['M'] ? param['M'].to_i : 1
            width = v_in_micron param['W']
            length = v_in_micron param['L']
            key = "#{width}/#{length}/#{m}"
            puts "key=#{key} for #{param}"
            if params = ba_data[dc][key]
              puts '=&gt; OK'                  
              params['W'] = width
              #yield  l, params, current, new_netlist
              update_parameters l, params, current, new_netlist
              next
            else
              total_width = width * m
              n = 2
              puts "Try width =  #{(total_width/n).round(4)} &gt; #{length}"
              done = false
              while (width = (total_width/n).round(4)) &gt; length
                key = "#{width}/#{length}/#{n}"
                puts "Try key=#{key}"
                if params = ba_data[dc][key]
                  params['M']  = n
                  params['W'] = width
                  #yield  l, params, current, new_netlist
                  update_parameters l, params, current, new_netlist
                  done = true
                  break
                end
                n = n + 1
              end
              next if done
            end
          end
        end
        new_netlist &lt;&lt; l
      }
      File.open(file, 'w'){|f| f.puts new_netlist}
      puts "#{file} updated"
    end
    def ba_netlist_final netlist, file, ba_source=@ba, &amp;block
      new_netlist = ''
      ba_data = nil
      netlist.each_line{|l|
        if l.upcase =~ /^\.SUBCKT +(\S+)/
          cname = $1
          ba_data = ba_source[cname]
        elsif l =~ /^([Mm]\S+) +\S+ +\S+ +\S+ +\S+ +(\S+) +(.*)$/
          en = $1
          # dc = $2
          current = $3         
          if params = ba_data[en]
            puts ba_data[en].inspect
            param = current.upcase.scan(/(\S+) *= *(\S+)/).to_h
            # params['W'] = v_in_micron param['W'] if param['W'] == '0' || param['W'] == '0.0u'
            if m = param['M']
              params['M'] = m.to_i
              params['W'] = params['W'].to_f / params['M']
            end
            # arams['L'] = v_in_micron param['L']
            #yield  l, params, current, new_netlist
            update_parameters l, params, current, new_netlist
            next
          end
        end
        new_netlist &lt;&lt; l
      }
      File.open(file, 'w'){|f| f.puts new_netlist}
      puts "#{file} updated"
    end
    def ba_xschem netlist, file, ba_data=@ba, &amp;block
      new_netlist = ''
      netlist.each_line{|l|
        if l =~ /^C {(.*)\.sym}.*name=x(\d+)/
          cell = "#{$1}.sch"
          unless @converted.include? cell
            ba_xschem File.read(cell), cell, ba_data[$2]
            @converted &lt;&lt; cell
          end
        elsif l =~ /^C {(.*)\.sym}.*name=(M\d+) (.*)}/
          current = $3
          params = ba_data[$2]
          #yield l, params, current, new_netlist
          update_parameters l, params, current, new_netlist
          next
        end
        new_netlist &lt;&lt; l
      }
      File.open(file, 'w'){|f| f.puts new_netlist}
      puts "#{file} updated"
    end
    def ba_ltspice netlist, file, ba_data, &amp;block
      #puts ba.inspect
      new_netlist = ''
      symbol = prefix = id = nil
      netlist.each_line{|l|
        if l =~ /^SYMBOL (\w+)/
          symbol = $1
        elsif l =~ /^SYMATTR InstName X(\d+)/
          id = $1
          cell = "#{symbol}.asc"
          unless @converted.include? cell
            data = ba_data['X' + id] || ba_data[symbol.upcase]
            ba_ltspice File.read(cell), cell, data, &amp;block
            @converted &lt;&lt; cell
          end
        elsif l =~ /^SYMATTR InstName (\w)(\d+)/
          prefix = $1
          id = $2
        elsif l =~ /^SYMATTR Value2 (.*)$/
          current = $1
          if prefix == 'M'
            params = ba_data[prefix+id]
            #yield l, params, current, new_netlist
            update_parameters l, params, current, new_netlist
            next
          end
        end
        new_netlist &lt;&lt; l
      }
      File.open(file, 'w'){|f| f.puts new_netlist}
      puts "#{file} updated"
    end
  end
  app = Application.instance
  mw = app.main_window
  cv = mw.current_view.active_cellview  
  ba = Backannotate.new cv
  begin
    sch = QFileDialog::getOpenFileName(mw, 'Schematic file', File.dirname(cv.filename), 'schematic(*.asc *.sch)')
    #ba.backannotate 'op2_tb.sch'
    (sch == '' &amp;&amp; sch =nil) || net = QFileDialog::getOpenFileName(mw, 'Netlist file', File.dirname(cv.filename), 'schematic(*.net *.cir *.spice *.sp *.spc)')
    ba.backannotate(sch||net)
  rescue =&gt; error
    puts error
    puts "Backannotation might not exist under #{File.dirname cv.filename}!"
  end  
end
</text>
</klayout-macro>
